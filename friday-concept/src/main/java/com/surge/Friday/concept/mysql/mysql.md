 MySQL

1.事务：
	 数据库事务四大特性：原子性、一致性、隔离性、持久性

	 隔离级别：读未提交、读已提交、可重复读、序列化

	 隔离级别如何实现的？ 
	 MySQL全表的数据存储在以主键值为排序的B+树索引中，叶子结点存储了相应主键的整行记录，都是最新值，有可能已经提交，有可能未提交。
		 读未提交：写事务在相应数据上加共享锁， 所有的读操作不枷锁 直接读叶子结点上的最新值，所以有可能读到未提交的值。没有MVCC

		 读已提交：MVCC 在每行数据加入隐藏字段 实现了不枷锁的读操作。
		 		 所有不加锁的读操作 如果叶子节点上的数据正被其他事物占据，顺着DATA_ROLL_PTR指针找到上一个有效的记录。
		 		 所有写操作依然是加入行级的排他锁，在事务开始，回往UNDO日志中写入当前的有效值，DATA_ROLL_PTR会存储指向 UNDO日志的指针，指针指向一个链表，记录历史记录。

		 可重复读：在事务开始时，除了写UNDO日志外，还会形成一个ReadView 记录当前其他活跃事物ID。Tmin和Tmax。
		 		 在执行不加锁的select操作时，mySQL会顺着DATA_ROLL_PTR指针查找出符合条件的历史版本。会用到DATA_TRX_ID更新改记录的事务ID。如果DELETE_BIT=1则证明被删除。
		 		 扫描历史记录形成的链表的过滤条件是：如果当前历史记录的TID小于Tmin，或者如果在ReadView之间，但是不在ReadView中 （已经执行完毕）== 由DELETE决定。
		 		 							  否则 视为不可见，顺着DATA_ROLL_PTR进入上一个历史版本。
		 		 如果用share in mode 或者for update，都是当前读，读的是叶子节点上的值，如果第一次为快照读，第二次为当前读怎会出现幻读的情况，第一次加锁则不会。
		 		 在执行写操作时，如果WHERE的条件列上有唯一索引，那么MySQL只加行级锁；如果是普通索引，会加间隙锁来防止幻读；如果没有索引，就会首先锁表的所有记录、再释放不符合条件的行的锁，因此会大大降低并发写的能力。							  
		 
		 串行：  	 读和写操作都加表级锁，直接读主键索引B+树的叶子节点的最新数据。

	 什么是幻读： 在一个事务中，后一次查询到了前一次查询没有的数据。

	 如何避免幻读：读取数据时加共享锁，写数据时加排他锁，都是事务提交才释放锁。
	 			在快照读读情况下，mysql通过mvcc来避免幻读。
				在当前读读情况下，mysql通过next-key来避免幻读。
				
	 数据库事务如何实现：隔离性是锁机制 一致性是undo redo日志 原子性是commit 持久性写入磁盘

	 分布式事务： 2PC 两端提交。 第一次预提交，如果结果都成功，第二阶段统一提交。
	 			TCC 解决了2PC单点问题（主从业务方）和同步阻塞（超时机制）
	 			saga 本地事务备份副本，失败就会滚。
								
2.锁的概念
	行锁和间隙锁
		行锁： 单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身。在索引上加入X锁。
		间隙锁： 在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁。

	使用表锁？
		不通过索引条件检索数据时，或者检索范围太大接近全表。表锁

	什么时候使用行锁？
		当前读，更新、删除。行锁		

	如果一张表有多条记录被上gap锁，但这是不可接受的，如何避免或者减小gap锁的影响。
		减少基于范围的数据检索过滤条件

	意向锁
		意向锁的存在是为了平衡 行锁和表锁。
		意向锁是表级别锁。

4.索引
	什么是索引？ 
		索引是一种加快查询速度的数据结构

	聚集索引与非聚集索引
		聚集索引就是主键索引，每个叶子节点存放着完整的数据。非聚集索引每个叶子节点存放着着主键ID。
		一个表中存在主键后，整齐排列的数据会转变成平衡树的结构，整个表就变成了一个索引，所以叫做聚集索引。
		如果没有主键，InnoDB会寻找一个唯一非空索引作为聚集索引，如果没有，则隐式的定义一个主键。

	索引的种类
		主键索引，唯一索引，普通索引，全文索引

	mysql的复合索引
		MySQL的复合索引遵循了最左前缀原则。
		ABC A/AB/ABC

	查询在什么时候不走（预期中的）索引
		like
		非最左前缀顺序
		where order by limit 
		where 对null判断 
		在where查询中使用了or关键字 （Innodb）用UNION替换OR,可以使用索引。

	mysql索引对排序的优化
		首先order by的条件列满足索引的最左前缀原则 以及where 和order by 组合满足最左前缀原则
		索引是覆盖索引

	mysql的排序方式
		index排序： 扫描索引本身完成排序
		filesort排序：单路排序 直接读取磁盘上的数据进入缓存中，再缓存中重新排序。顺序读取不是随机读取，占用空间比较大。
					 双路排序，第一次读到索引指向的数据位置，第二次读取位置上的数据。需要两次磁盘IO。

3.主从复制
	mysql的主从复制有哪些模式？默认使用哪种模式？原理？
		异步 半同步 全同步
		1.slave 连接上master时 启动一个log dump线程，读取binlog 加锁。
		2。slave 的IO线程收到binlog后保存到relaylog中
		3。sql线程重新执行
		4、默认 1 分钟同步一次

    mysql5.8相对于以前版本在主从复制上做了哪些改进？	
    	5.7增加了多线程
    	5.6增加了GTID

    如何使用binlog在系统异常时恢复数据？
    	show master logs 查看binlog 的日志文件
    	show master status 
    	fiush logs
    	mysqlbinlog 命令查看
    	/usr/bin/mysqlbinlog  --stop-position=435 --database=hello  /var/lib/mysql/mysql-bin.000006 | /usr/bin/mysql -uroot -p密码 -v hello

    mysql的几种主从结构
    	一主多从 多主一从 多主一从

6.底层：
	mysql底层数据结构是啥？
		B+树  			

	对于行数据存储有几种格式？默认格式是啥？
		Mysql 目前有4种行格式：Redundant、Compact、Dynamic、Compressed
		5.6是Compact 5.7是Dynamic

	这几种格式的主要区别是啥？
		B-tree存储变长列 固定768
		压缩了空间
		提高储存容量 支持大索引
		支持数据和索引的压缩

	如何理解数据页以及为什么使用这种结构。
		innodb的数据页默认是16kb大小 减少和磁盘的IO次数。

	innoDB里的LRU实现
		Buffer pool 有三个链表 第一个空闲链表 free 第二个 执行到磁盘上的链表 flush  第三个LRU链表 分为old 和young 3:5的比例，第一次会把数据页放入到old区 如果第二次被访问的时间超过1秒就放入young区。

7.分布式
	如何保证数据库与缓存一致
		读：先读缓存 再读数据库 放入缓存中
		写：先更新数据库，在删除缓存

	数据库分表一般在多大的量才需要
		1000w

	分库分表带来的分布式困境有哪些？对应策略是啥？
		事务 数据迁移 排序 分页

8.RC和RR的区别：
	显然 RR 支持 gap lock(next-key lock)，而RC则没有。因为MySQL的RR需要gaplock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般要好于RR；
	RC 隔离级别不支持 statement 格式的bin log，因为该格式的复制，会导致主从数据的不一致；
	RC半一致性读。减少了update语句时行锁的冲突；对于不满足update更新条件的记录，可以提前放锁，减少并发冲突的概率；

9.不同级别下的MVCC的区别：
	RC：在每次语句执行的过程中，都关闭ReadView，每次重新生成当前状态的ReadView。
	RR：在创建事务的时候就声称了ReadView,一支维持到事务结束。

数据库优化思路
	用--log-slow-queries(查询日志)   --log-queries-not-using-indexes(查询未使用索引日志)	 
	用explain 或者是desc tableName 解析。
	查看耗时 set profiling=1。

如何分析慢查询
	查看慢查询  show status like 'slow_queries'; 设置慢查询时间 show variables like 'long_query_time';
	expain / 查看slow.log 中的查询时间、锁的时间、影响行数、sql内容

Insert的执行流程
	执行insert语句，判断是否有和插入意向锁冲突，有加入意向锁，进入锁等待。如果没有直接写数据
	执行commit Reads 判断是否有其他活跃的事务，如果有给他创建一个X锁 自己进入锁等待 （第一次是快照读，第二次是当前读）
